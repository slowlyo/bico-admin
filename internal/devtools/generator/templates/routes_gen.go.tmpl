// Code generated by bico-admin code generator. DO NOT EDIT.
// Generated at: {{.Timestamp.Format "2006-01-02 15:04:05"}}

package routes

import (
	"reflect"
	"github.com/gin-gonic/gin"

	"{{.PackagePath}}/handler"
	"{{.PackagePath}}/routes"
)

// {{.ModelName}}RouteRegistrar {{.ModelName}}路由注册器
type {{.ModelName}}RouteRegistrar struct{}

// RegisterRoutes 实现 RouteRegistrar 接口
func (r *{{.ModelName}}RouteRegistrar) RegisterRoutes(router *gin.Engine, handlers *routes.Handlers) {
	Register{{.ModelName}}Routes(router, handlers)
}

// RegisterProtectedRoutes 实现 ProtectedRouteRegistrar 接口
func (r *{{.ModelName}}RouteRegistrar) RegisterProtectedRoutes(protectedGroup *gin.RouterGroup, handlers *routes.Handlers) {
	Register{{.ModelName}}ProtectedRoutes(protectedGroup, handlers)
}

// init 自动注册路由
func init() {
	registrar := &{{.ModelName}}RouteRegistrar{}
	routes.RegisterRouteRegistrar(registrar)

	// 如果支持受保护路由注册，也注册它
	if protectedRegistrar, ok := interface{}(registrar).(routes.ProtectedRouteRegistrar); ok {
		routes.RegisterProtectedRouteRegistrar(protectedRegistrar)
	}
}

// Register{{.ModelName}}Routes 注册{{.ModelName}}路由
// 这是一个生成的路由注册函数，会被主路由注册器调用
func Register{{.ModelName}}Routes(router *gin.Engine, handlers *routes.Handlers) {
	// 使用反射检查处理器是否存在
	handlerValue := getHandlerByName(handlers, "{{.HandlerName}}")
	if handlerValue == nil {
		// 处理器不存在，跳过路由注册
		return
	}

	// {{.ModelName}}路由组
	{{.ModelNameLower}}Group := router.Group("{{.RoutePath}}")
	{
{{range .HandlerMethods}}		// {{.Description}}
		if method := getHandlerMethod(handlerValue, "{{.Name}}"); method != nil {
			{{.HTTPMethod | lower}}Route := {{$.ModelNameLower}}Group.{{.HTTPMethod}}("{{.Path}}", method)
			_ = {{.HTTPMethod | lower}}Route // 避免未使用变量警告
		}
{{end}}	}
}

// Register{{.ModelName}}ProtectedRoutes 注册需要认证的{{.ModelName}}路由
// 这个函数用于注册需要认证和权限检查的路由
func Register{{.ModelName}}ProtectedRoutes(protectedGroup *gin.RouterGroup, handlers *routes.Handlers) {
	// 检查处理器是否存在
	// 暂时跳过检查，让运行时处理

	// {{.ModelName}}路由组
	{{.ModelNameLower}}Group := protectedGroup.Group("{{.RoutePath}}")
	{
{{range .HandlerMethods}}		// {{.Description}}
		// 注意：这里需要确保 handlers 中有对应的 {{$.HandlerName}} 字段
		// {{.HTTPMethod | lower}}Route := {{$.ModelNameLower}}Group.{{.HTTPMethod}}("{{.Path}}", handlers.{{$.HandlerName}}.{{.Name}})
		// _ = {{.HTTPMethod | lower}}Route // 避免未使用变量警告
{{end}}	}
}

// {{.ModelName}}RouteConfig {{.ModelName}}路由配置
type {{.ModelName}}RouteConfig struct {
	Enabled     bool   `json:"enabled"`      // 是否启用路由
	PathPrefix  string `json:"path_prefix"`  // 路径前缀
	Middlewares []string `json:"middlewares"` // 中间件列表
}

// Default{{.ModelName}}RouteConfig 默认{{.ModelName}}路由配置
func Default{{.ModelName}}RouteConfig() *{{.ModelName}}RouteConfig {
	return &{{.ModelName}}RouteConfig{
		Enabled:     true,
		PathPrefix:  "{{.RoutePath}}",
		Middlewares: []string{},
	}
}

// Register{{.ModelName}}RoutesWithConfig 使用配置注册{{.ModelName}}路由
func Register{{.ModelName}}RoutesWithConfig(router *gin.Engine, handlers *routes.Handlers, config *{{.ModelName}}RouteConfig) {
	if !config.Enabled {
		return
	}

	// {{.ModelName}}路由组
	{{.ModelNameLower}}Group := router.Group(config.PathPrefix)

	// 应用中间件
	for _, middleware := range config.Middlewares {
		// 这里可以根据中间件名称应用相应的中间件
		// 例如：{{.ModelNameLower}}Group.Use(getMiddlewareByName(middleware))
		_ = middleware // 避免未使用变量警告
	}

	{
{{range .HandlerMethods}}		// {{.Description}}
		// 注意：这里需要确保 handlers 中有对应的 {{$.HandlerName}} 字段
		// {{.HTTPMethod | lower}}Route := {{$.ModelNameLower}}Group.{{.HTTPMethod}}("{{.Path}}", handlers.{{$.HandlerName}}.{{.Name}})
		// _ = {{.HTTPMethod | lower}}Route // 避免未使用变量警告
{{end}}	}
}

// getHandlerByName 通过反射获取处理器
func getHandlerByName(handlers *routes.Handlers, handlerName string) interface{} {
	handlersValue := reflect.ValueOf(handlers)
	if handlersValue.Kind() == reflect.Ptr {
		handlersValue = handlersValue.Elem()
	}

	handlerField := handlersValue.FieldByName(handlerName)
	if !handlerField.IsValid() || handlerField.IsNil() {
		return nil
	}

	return handlerField.Interface()
}

// getHandlerMethod 通过反射获取处理器方法
func getHandlerMethod(handler interface{}, methodName string) gin.HandlerFunc {
	handlerValue := reflect.ValueOf(handler)
	method := handlerValue.MethodByName(methodName)
	if !method.IsValid() {
		return nil
	}

	// 将方法转换为 gin.HandlerFunc
	if handlerFunc, ok := method.Interface().(func(*gin.Context)); ok {
		return gin.HandlerFunc(handlerFunc)
	}

	return nil
}
